Android开发中，我们经常用到各种开源框架，很多优秀的框架不仅提供了功能丰富的功能接口，其高超的代码编写和组织水平也值得我们学习。通过学习这些框架的源码，有助于快速提高我们的编程质量。在接下来的博客中，我将对一系列优秀的开源框架源码进行阅读分析，目的有两个，一是理解框架的实现机制，从源码的角度去分析怎样更好的使用这些框架。二是从这些优秀的源码中学习如何组织代码，如何实现高质量的编程。本文我们将分析Android图片加载工具Picasso源码。

我们从Picasso使用方式上入手，Picasso的使用通常分为两步，第一步初始化Picasso单例，第二步获取Picasso单例，创建RequestCreator，加载图片。代码示例如下：

Picasso初始化用到了单例模式和构造者模式。关于构造者模式的讲解可以查看这篇文章（http://www.jianshu.com/p/13058bc5b514），此处不再赘述。在Picasso初始化用到Picasso.Builder静态内部类，有以下设置项：

这样就完成了Picasso单例的初始化，并完成了一些全局的设置。接下来可以通过这个单例加载图片并展示了。

获取到Picasso单例对象后，调用picasso.load函数，返回一个RequestCreator对象，该对象用于构造一个具体的加载图片请求Request。

RequestCreator采用了构造者模式，提供了一系列设置函数，可以设置本次要加载图片的裁剪方式，缩放方式，旋转角度等。

RequestCreator对外提供了一系列设置函数，返回的都是同一个RequestCreator对象，标准的构造者模式。完成所有设置后，调用into函数实现Request对象的最终构造。

这个函数是个很关键的函数，我们可以将它作为理解Picasso加载过程的一条主线。该函数首先通过checkMain检查是不是在主线程发起调用，由于加载图片需要对UI进行操作，所以必须在主线程进行函数的调用。

checkMain的实现是通过比较当前线程和MainLooper线程是否是同一个线程进行的。

完成主线程检查后，判断有没有设置图片来源，包括Uri或Resource ID等，如果没设置不进行加载。

接下来判断可以立即加载，还是需要延迟加载。延迟加载的场景是使用fit()方法进行图片尺寸自适应调整的时候。如果设置图片根据需要展示的View的尺寸进行自动调整，而且这个View的宽度或高度设置为0（比如通过weight进行相对宽高的设置），那么代码执行到这里的时候View可能还没完成测量的过程，还没有计算出实际的宽高，就需要等测量完成后才进行加载，也就是延迟加载，这里作为into函数三个分支的第一个分支。

DeferredRequestCreator实现延迟加载，是通过给目标View注册onAttachStateChangeListener监听器实现的，监听器的两个接口函数onViewAttachedToWindow，onViewDetachedFromWindow分别对应了一个View被放置到界面上，和从界面上收回两个时间节点。在onViewAttachedToWindow中，给view的ViewTreeObserver添加onPreDrawListener监听器，并在onViewDetachedFromWindow中删除该监听器。onPreDrawListener监听器的onPreDraw接口函数会在界面完成测量后将要被展示出来前调用，此时可以获取到view的宽高，从而知道需要将加载的图片缩放到的具体尺寸。获取到具体尺寸后就可以通过unfit函数取消延迟加载的标识，通过resize设置尺寸，最后通过into函数生成最终的Request并提交到线程池去执行。

这是into函数里面需要延迟执行的情形的处理。如果没有通过fit进行自适应，而是一开始就指定了需要加载图片的宽高，就走第二个分支的逻辑，尝试从缓存获取。

从createKey的实现可以看出，同一个来源的图片，如果加载参数不同，会生成不同的key，并分别存储到缓存中。接下来判断是否设置了内存缓存，如果设置的话通过picasso.quickMemoryCacheCheck根据key查找缓存内容，找到的话返回这个bitmap，并设置给view。

可以看到，Cache是一个接口类，规范了一系列对缓存的操作接口，包括get/set/size/clear等，还包含一个空实现。Picasso提供了一个实现了Cache接口的类LruCache，用户也可以提供自己的实现。

LruCache通过一个LinkedHashMap来存储图片键值对，LinkedHashMap结合了链表的FIFO特性以及HashMap的键值对存取特性，通过iterator遍历的时候保证先加入的先遍历到，当缓存的大小达到设定值的时候，通过trimToSize函数进行缓存的换出，借助LinkedHashMap实现FIFO的换出策略。同时注意由于多个线程可以同时存取缓存，需要进行线程同步机制，这里是通过synchronized加锁实现的。

这里一次图片加载的操作是通过一个Action来表示的，Action是一个接口类，提供了跟一次图片加载相关的操作，比如请求的Request，网络缓存策略，内存缓存策略，加载成功的回调函数，失败的回调，取消的回调等。

Picasso提供了几种Action的实现，包括ImageViewAction（图片加载并展示到ImageView），NotificationAction（图片加载并展示到Notification），GetAction（图片同步加载不展示），FetchAction（图片异步加载并设置回调函数）等，下面给出ImageViewAction的代码：

可以看到performSubmit函数会根据每个Action创建一个BitmapHunter对象，并通过ExecutorService提交到线程池执行。BitmapHunter是一个多线程类，提供了加载图片的操作：

再次尝试从内存缓存获取，之前没在内存缓存中，说不定这时候已经在了。如果获取不到，调用RequestHandler的load函数进行真正的加载操作。

RequestHandler是个虚基类，提供了统一的加载接口：

NetworkRequestHandler，ContactsPhotoRequestHandler，AssetRequestHandler，ContentStreamRequestHandler,ResourceRequestHandler等都实现了RequestHandler基类，分别提供了网络加载，联系人图片加载，Asset资源加载，文件加载，Resource资源图片加载等不同的加载方式。

这样，就完成了Picasso加载图片的整个流程分析。代码量适中，结构也比较清晰，适合阅读学习。